scenario = 'Pulse image reconstruction';

groups{1} = get_group('Data load parameters', 'fbp');
groups{2} = get_group('Time domain', 'td');
groups{3} = get_group('Multi-B parameters', 'MBpars');
groups{4} = get_group('FFT and projection correction', 'fft');
groups{5} = get_group('Reconstruction parameters', 'rec');
groups{6} = get_group('Fitting parameters', 'fit');
groups{7} = get_group('Calibration parameters', 'clb');
groups{8} = get_group('Processing parameters', 'prc');

fields_FBP{1} = get_input_fields('Scheme', 'scheme', 'multi_b', 'IDXS');
fields_FBP{end}.Show = {'SB', 'MB'};
fields_FBP{end}.Options = {'single_b', 'multi_b'};
fields_FBP{end+1} = get_input_fields('Sequence', 'sequence', '2pECHO', 'IDXS');
fields_FBP{end}.Show = {'2pECHO','2pECHOSRT','3pT1','ESEInvRec'};
fields_FBP{end}.Options = {'2pECHO','2pECHOSRT','3pT1','ESEInvRec'};
fields_FBP{end+1} = get_input_fields('Polar angles', 'nPolar', 18, 'D');
fields_FBP{end+1} = get_input_fields('Azimuth. angles', 'nAz', 18, 'D');
fields_FBP{end+1} = get_input_fields('Image type','imtype', 14, 'IDX');
fields_FBP{end}.Show = {'4D XYZB', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '3D XYZ'};
fields_FBP{end}.Options = {'4D XYZB', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '3D XYZ'};
fields_FBP{end+1} = get_input_fields('Maximum gradient','MaxGradient', 1.5, 'D');
fields_FBP{end+1} = get_input_fields('Angular scheme','angle_sampling', 'uniform_angular_flip', 'IDXS');
fields_FBP{end}.Show = {'uniform_spatial_flip', 'uniform_angular_flip'};
fields_FBP{end}.Options = {'uniform_spatial_flip', 'uniform_angular_flip'};
fields_FBP{end+1} = get_input_fields('Coord. pole','CoordPole', 'Z', 'IDXS');
fields_FBP{end}.Show = {'X', 'Y', 'Z'};
fields_FBP{end}.Options = {'X', 'Y', 'Z'};
fields_FBP{end+1} = get_input_fields('Baseline type','baseline', 'every_n', 'IDXS');
fields_FBP{end}.Show = {'none', 'before', 'after', 'before_after', 'every_n', 'from_file'};
fields_FBP{end}.Options = {'none', 'before', 'after', 'before_after', 'every_n', 'from_file'};
fields_FBP{end+1} = get_input_fields('Baseline frequency','bl_n', 4, 'D');

fields_TD{1} = get_input_fields('Baseline display', 'baseline_display', 'none', 'IDXS');
fields_TD{end}.Show = {'None', 'All', 'By slice'};
fields_TD{end}.Options = {'none', 'all', 'all_by_slice'};
fields_TD{end+1} = get_input_fields('Phase display', 'phase_display', 'none', 'IDXS');
fields_TD{end}.Show = {'None', 'All', 'By slice'};
fields_TD{end}.Options = {'none', 'all', 'all_by_slice'};
fields_TD{end+1} = get_input_fields('BL Algorithm', 'baseline_algorithm', '', 'IDXS');
fields_TD{end}.Show = {'None', 'Zero order, trace-by-trace', 'Zero order, global', 'First order, trace-by-trace'};
fields_TD{end}.Options = {'none', 'zero_single', 'zero_all', 'first_single'};
fields_TD{end+1} = get_input_fields('BL Area [pts]', 'baseline_area', '200:1200', 'D');
fields_TD{end+1} = get_input_fields('Dead time [ns]', 'dead_time', '580', 'D');
fields_TD{end+1} = get_input_fields('Acquisition trigger [ns]', 'acq_window_start', '-2200', 'D');
%fields_TD{end+1} = get_input_fields('PRE filter', 'filt_before', 'none', 'S');
%fields_TD{end+1} = get_input_fields('PRE filter', 'tc_before', 18, 'D');
fields_TD{end+1} = get_input_fields('ZERO sample echo(s)', 'use_echos', '[]', 'D');
fields_TD{end+1} = get_input_fields('ZERO time algorithm', 'echo_select_algorithm', 'statistics', 'IDXS');
fields_TD{end}.Show = {'Manual', 'Statistics based', 'Trace-by-trace'};
fields_TD{end}.Options = {'manual', 'statistics', 'single'};
fields_TD{end+1} = get_input_fields('ZERO manual index [pts]', 'echo_idx', 18, 'D');
fields_TD{end+1} = get_input_fields('PHASE algorithm', 'phase_algorithm', 'phase_zero_order', 'IDXS');
fields_TD{end}.Show = {'None', 'Manual (0-order)', 'Maximum real part (0-order)', 'Maximum real part w smooth (0-order)', 'max_real_all', 'max_real_poly3','max_real_manual','min_imag_manual'};
fields_TD{end}.Options = {'None', 'manual_zero_order', 'max_real_single', 'max_real_single_smooth', 'max_real_all', 'max_real_poly3','max_real_manual','min_imag_manual'};
fields_TD{end+1} = get_input_fields('PHASE zero order [deg]', 'phase_zero_order', 0, 'D');
%fields_TD{end+1} = get_input_fields('DECAY correction', 'echo_decay_correction', 'none', 'S');
%fields_TD{end+1} = get_input_fields('DECAY T2', 'echo_decay_T2', 4, 'D');

fields_MBPARS{1} = get_input_fields('Profile threshold (0-1)', 'MBprofThresh', 0.2, 'D');
fields_MBPARS{end+1} = get_input_fields('Profile truncation [MHz]', 'MBProjTrunc', '[-10 10]', 'D');
fields_MBPARS{end+1} = get_input_fields('Recombine scheme', 'MBrecombine_scheme', 'inv_square', 'IDXS');
fields_MBPARS{end}.Show = {'inverse square', 'inverse cube', 'inverse linear'};
fields_MBPARS{end}.Options = {'inv_square', 'inv_cube', 'inverse'};
fields_MBPARS{end+1} = get_input_fields('Projection Offsets [G]','Offsets','[-2 2]','D');
fields_MBPARS{end+1} = get_input_fields('Adaptive multi-B Technique','MBadaptive','1','IDXS');
fields_MBPARS{end}.Show = {'1. None', '2. Vary Step Size Only', '3. Vary Step Number'};
fields_MBPARS{end}.Options = { '1', '2', '3'};
fields_MBPARS{end+1} = get_input_fields('Large Dimension Size [cm]', 'LargeDimension', '7.5', 'D');
fields_MBPARS{end+1} = get_input_fields('Small Dimension Size [cm]', 'SmallDimension', '2.5', 'D');
fields_MBPARS{end+1} = get_input_fields('Maximum Step Width [G]', 'MaxStepWidth', '2.0', 'D');
fields_MBPARS{end+1} = get_input_fields('Longest Dimension', 'LongAx', '2', 'IDXS');
fields_MBPARS{end}.Show = {'1. X', '2. Y', '3. Z'};
fields_MBPARS{end}.Options = { '1', '2', '3'};

fields_FFT{1} = get_input_fields('Display', 'fft_display', 'all', 'IDXS');
fields_FFT{end}.Show = {'None', 'All', 'By slice'};
fields_FFT{end}.Options = {'none', 'all', 'all_by_slice'};
fields_FFT{end+1} = get_input_fields('Display imaginary', 'fft_display_imag', 'all', 'IDXS');
fields_FFT{end}.Show = {'None', 'All', 'By slice'};
fields_FFT{end}.Options = {'none', 'all', 'all_by_slice'};
%fields_FFT{end+1} = get_input_fields('awin', 'awin', 'none', 'S');
%fields_FFT{end+1} = get_input_fields('awidth', 'awidth', 1, 'D');
%fields_FFT{end+1} = get_input_fields('aalpha', 'aalpha', 1, 'D');
%fields_FFT{end+1} = get_input_fields('ashift', 'ashift', 0, 'D');
%fields_FFT{end+1} = get_input_fields('awings', 'awings', 'off', 'S');
%fields_FFT{end+1} = get_input_fields('opt', 'opt', 'imag', 'S');
%fields_FFT{end+1} = get_input_fields('fft', 'fft', 1, 'D');
%fields_FFT{end+1} = get_input_fields('zerofill', 'zerofill', 1, 'D');
%fields_FFT{end+1} = get_input_fields('phase0', 'phase0', 0, 'D');
fields_FFT{end+1} = get_input_fields('Projection zero offset [MHz]', 'xshift', 0, 'D');
%fields_FFT{end+1} = get_input_fields('filt', 'filt', 'none', 'S');
%fields_FFT{end+1} = get_input_fields('tc', 'tc', 33, 'D');
fields_FFT{end+1} = get_input_fields('FT zero time position', 'data', '0_', 'IDXS');
fields_FFT{end}.Show = {'Echo decay', 'Full echo'};
fields_FFT{end}.Options = {'0_', '_0_'};
fields_FFT{end+1} = get_input_fields('Offset of profile [MHz]', 'profile_center_offset', 0, 'D');
fields_FFT{end+1} = get_input_fields('Profile correction', 'profile_correction', 'imager_profile', 'IDXS');
fields_FFT{end}.Show = {'Imager profile(file)', 'Lorentzian'};
fields_FFT{end}.Options = {'imager_profile', 'lorentz'};
fields_FFT{end+1} = get_input_fields('Profile correction file', 'profile_file', 'ffff', 'F');
fields_FFT{end+1} = get_input_fields('Profile threshold (0-1)', 'profile_threshold', 0.25, 'D');
fields_FFT{end+1} = get_input_fields('Profile FWHH [MHz]', 'profile_fwhh', 10, 'D');
fields_FFT{end+1} = get_input_fields('Smooth threshold', 'profile_threshold_smooth', 0, 'D');
fields_FFT{end+1} = get_input_fields('Clearence correction', 'clearence_correction', 'none', 'S');

fields_REC{1} = get_input_fields('Reconstruct echos', 'recon_echos', [], 'D');
fields_REC{end+1} = get_input_fields('Matrix size', 'Sub_points', 64, 'D');
fields_REC{end+1} = get_input_fields('FOV/sqrt(2) [cm]', 'Size', 3.0, 'D');
fields_REC{end+1} = get_input_fields('DoublePoints', 'DoublePoints', 3.0, 'D');
fields_REC{end+1} = get_input_fields('InterpFactor', 'InterpFactor', 4, 'D');
fields_REC{end+1} = get_input_fields('Filter', 'Filter', 'ram-lak', 'S');
fields_REC{end+1} = get_input_fields('Interpolation', 'Interpolation', 'spline', 'S');
fields_REC{end+1} = get_input_fields('FilterCutOff', 'FilterCutOff', 0.5, 'D');
%fields_REC{end+1} = get_input_fields('Enabled', 'Enabled', 'on', 'S');

fields_FIT{1} = get_input_fields('Use data from tau', 'use_echos', [], 'D');
fields_FIT{end+1} = get_input_fields('Mask', 'fit_mask', 'threshold_mask', 'IDXS');
fields_FIT{end}.Show = {'Threshold', 'External file'};
fields_FIT{end}.Options = {'threshold_mask', 'external_file'};
fields_FIT{end+1} = get_input_fields('External mask file', 'fit_mask_file', 'ffff', 'F');
fields_FIT{end}.Flags = hex2dec('0');
fields_FIT{end+1} = get_input_fields('Fitting function', 'fit_function', 'fit_exp_no_offset', 'IDXS');
fields_FIT{end}.Show = {'T2 no offset', 'T1 3 param fit'};
fields_FIT{end}.Options = {'fit_exp_no_offset', 'fit_exp_recovery'};
fields_FIT{end+1} = get_input_fields('Saturation correction', 'sat_correction', 'none', 'IDXS');
fields_FIT{end}.Show = {'No Correction', 'Fixed T1', 'T1=1.2*T2' };
fields_FIT{end}.Options = {'none', 'Fixed_T1', 'T2_based'};
fields_FIT{end+1} = get_input_fields('T1 [us]', 'T1', 6, 'D');
fields_FIT{end+1} = get_input_fields('Mask threshold (0-1)', 'fit_mask_threshold', 0.1, 'D');
fields_FIT{end+1} = get_input_fields('Consider fit errors as bad voxels', 'fit_errors_kill', 'yes', 'IDXS');
fields_FIT{end}.Show = {'Yes', 'No'};
fields_FIT{end}.Options = {'yes', 'no'};
fields_FIT{end+1} = get_input_fields('Minimum amplitude (0-1)*mean', 'fit_min_amp', 0, 'D');
fields_FIT{end+1} = get_input_fields('Maximum amplitude (0-1)*mean', 'fit_max_amp', 5, 'D');
fields_FIT{end+1} = get_input_fields('Minimum T2 [us]', 'fit_min_T2', 0, 'D');
fields_FIT{end+1} = get_input_fields('Maximum T2 [us]', 'fit_max_T2', 20, 'D');
fields_FIT{end+1} = get_input_fields('Minimum T1 [us]', 'fit_min_T1', 0, 'D');
fields_FIT{end+1} = get_input_fields('Maximum T1 [us]', 'fit_max_T1', 20, 'D');

fields_PRC{1} = get_input_fields('Processing type', 'process_method', 'ese_fbp', 'IDXS');
fields_PRC{end}.Show = {'Pulse ESE', '3p ESE T1', 'ESE Inv Rec', 'RT Saturation', 'CW 4D', 'Pulse MB ESE', 'T1 T2 combined'};
fields_PRC{end}.Options = {'ese_fbp', 'ese_fbp_3pT1', 'ese_fbp_InvRec', 'ese_fbp_SRT', 'cw_fbp', 'ese_mb_fbp', 'ese_fbp_T1T2InvRec'};
fields_PRC{end+1} = get_input_fields('Reconstruct data', 'recon_data', 'yes', 'IDXS');
fields_PRC{end}.Show = {'Yes', 'No'};
fields_PRC{end}.Options = {'yes', 'no'};
fields_PRC{end+1} = get_input_fields('Save data', 'save_data', 'yes', 'IDXS');
fields_PRC{end}.Show = {'Yes', 'No'};
fields_PRC{end}.Options = {'yes', 'no'};
fields_PRC{end+1} = get_input_fields('Fit data', 'fit_data', 'no', 'IDXS');
fields_PRC{end}.Show = {'Yes', 'No'};
fields_PRC{end}.Options = {'yes', 'no'};

fields_CLB{1} = get_input_fields('LLW_zero_po2 [mG]', 'LLW_zero_po2', 12.4, 'D');
fields_CLB{2} = get_input_fields('mG_per_mM [mG/mM]', 'mG_per_mM', 2.32, 'D');
fields_CLB{3} = get_input_fields('Torr_per_mGauss [torr/mG]', 'Torr_per_mGauss', 1.84, 'D');
fields_CLB{4} = get_input_fields('amp1mM', 'amp1mM', 0.065, 'D');